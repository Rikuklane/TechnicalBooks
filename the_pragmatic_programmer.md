# The Pragmatic Programmer, 20th Anniversary Edition - David Thomas, Andrew Hunt

The book starts off by expressing that there is no point in developing software unless you care about doing it well. A Pragmatic Programmer needs to constantly think and critique the work the do, and never run on auto-pilot. Such processes and time investments are repaid in the long term by having code that is easier to maintain. This can also help build trust in the team, which is important, as your team needs to be able to trust and rely upon you, and vise-versa. Another tool to build trust, is to take responsibility for everything you do - Provide solutions, not excuses. Before providing bad news, that something didn't work, think, is there something else that can be tried?

When disorder increases in software, it is called "software rot" or more optimistically "technical debt". But the same as with an apartement in a city, even one broken window can cause a clean, intact, inhabited building into a smashed and abandoned hulk, software code can start to deteriorate quite quickly with one bad design, wrong decision, or poor code left unfixed. Such problems should be fixed as soon as they are discovered or "boarded up" by a "Not implemented message". If the whole project has a couple of "broken windows", it is easy to be in the same mindset and make similar decisions, but if in the project, the code is cleanly written and well designed, people will take special care to not mess it up.

Time after time you might end up in a situation, in which, you know exactly what needs to be done, and how, but you are met with blank stares and delays. Then instead of asking permission (due to "start-up fatigue" and everyone guarding their own resources) it might make sense to bring out a MVP product, which just has the basics, and let everybody marvel. And then pretending it is not important saying that it would be better if we added this, and then repeat, until you add the functionality you originally wanted. Be a catalyst for change. Although such approach can have a not so good side effect, such as putting a frog put into a pan of cold water and gradually heating it up with the frog not noticing until cooked. Keep an eye on the big picture, and don't let projects to slowly get totally out of hand.

You shouldn't build perfect software, just good-enough software, which is just good-enough for the end-user needs. The scope and quality of the system should be discussed as its requirements as it is equally unprofessional to promise impossible time scales and to cut basic engineering corners to meet a deadline. Many users prefer to use software with some rough edges today rather than wait a year for the "shiny" version. In ways, programming is like painting, you constantly step back and view what you have done, and all hard work can be ruined when you don't know when to stop. It may not be perfect, but it could never be perfect.
