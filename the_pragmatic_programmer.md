# The Pragmatic Programmer, 20th Anniversary Edition - David Thomas, Andrew Hunt
Each paragraph in the following summary is based on 1 subchapter, and therefore the topic should be easy to find in the book.

## Chapter 1
There is no point in developing software unless you care about doing it well. A Pragmatic Programmer needs to constantly think and critique the work the do, and never run on auto-pilot. Such processes and time investments are repaid in the long term by having code that is easier to maintain. This can also help build trust in the team, which is important, as your team needs to be able to trust and rely upon you, and vise-versa. Another tool to build trust, is to take responsibility for everything you do - Provide solutions, not excuses. Before providing bad news, that something didn't work, think, is there something else that can be tried?

When disorder increases in software, it is called "software rot" or more optimistically "technical debt". But the same as with an apartement in a city, even one broken window can cause a clean, intact, inhabited building into a smashed and abandoned hulk, software code can start to deteriorate quite quickly with one bad design, wrong decision, or poor code left unfixed. Such problems should be fixed as soon as they are discovered or *boarded up* by a *Not implemented message*. If the whole project has a couple of *broken windows*, it is easy to be in the same mindset and make similar decisions, but if in the project, the code is cleanly written and well designed, people will take special care to not mess it up.

Time after time you might end up in a situation, in which, you know exactly what needs to be done, and how, but you are met with blank stares and delays. Then instead of asking permission (due to "start-up fatigue" and everyone guarding their own resources) it might make sense to bring out a MVP product, which just has the basics, and let everybody marvel. And then pretending it is not important saying that it would be better if we added this, and then repeat, until you add the functionality you originally wanted. Be a catalyst for change. Although such approach can have a not so good side effect, such as putting a frog put into a pan of cold water and gradually heating it up with the frog not noticing until cooked. Keep an eye on the big picture, and don't let projects to slowly get totally out of hand.

You shouldn't build perfect software, just good-enough software, which is just good-enough for the end-user needs. The scope and quality of the system should be discussed as its requirements as it is equally unprofessional to promise impossible time scales and to cut basic engineering corners to meet a deadline. Many users prefer to use software with some rough edges today rather than wait a year for the "shiny" version. In ways, programming is like painting, you constantly step back and view what you have done, and all hard work can be ruined when you don't know when to stop. It may not be perfect, but it could never be perfect.

 A programmers most strategic asset is to learn new things, and managing a knowledge portfolio is similar to managing a financial one, as regular (even if small) and diverse investments need to be done. Additionally it requires both conservative and high-risk, high-reward investments, where investments are bought low and sold high for maximum return. The portfolios should be reviewed and ba lances successfully. The options to invest regularly are to: Learn a new language, read a technical book, Read nontechnical (soft skills) books, take classes, participate in user groups & meetups, experiment with environments, stay current (read news and posts). When being asked a question, which you don't know the answer to, try to look it up yourself later. But you will still have to think critically, as bookstores might just have been payed to feature a book (doesn't mean it is good). To be critical, ask: *Why* five times, who does this benefit, what's the context (best for who), when & where would it work, why is this a problem.

Pragmatic thinking is ultimately sterile unless you communicate with other people. English (and other natural languages) is just another programming language, and the meaning of your conversation is the response you get. Plan what you want to say, write an outline, and refine until it matches what you want to communicate. Choose your moment, and if necessary ask "Is this a good time to talk about...?". When communicating, choose your style based on the audience, and make it look good. It is a good practise to involve your audience in document drafts, listen to their proposals, and to get back to them regarding these. There's also a matter of communicating via documentation, and it should also be kept close at hand - in the code itself. In order to not violate the DRY principle, non-API commenting should be restricted to **Why** it is done, as the code already shows **How** it is done.

## Chapter 2
A good design is easier to change than bad design as well designed things adapt to the people who use them. The principle is: **ETC - Easier to Change**, ETC is a value, not a rule, that guides you in the right direction. Some examples of ETC are: decoupling (isolating concerns), single responsibility principle (change in requirements - only change in 1 module), naming (you have to read to change). To enforce this, spend a week to deliberately asking: *Did the thing I just did make the overall system easier or harder to change?*. When you don't have a clue what is the best option either by (1) Trying to make the written code replacable, or (2) Document the choices in the source with the decision, to give yourself feedback later on.

To develop software reliably, and make it easier to understand and maintain then every piece of knowledge must have a single, unambiguous, authoritative representation within a system. This is the DRY(Don't Repeat Yourself) principle. The alternative is to have the same things expressed in *two* different places - which brings up the question *when do you forget, and not if*. DRY is about the duplication of _knowledge, of intent_, which also can possibly be expressed in two different ways (code, documentation, database). Though not all code duplication is knowledge duplication (e.g., functions for validating age or quantity), where the code is the same, but the knowledge is different. The code should not be commented with what the function does and what are its parameters as this knowledge already exists. The data structures also represent knowledge, and to not fall out with the DRY principle, they should also contain knowledge only once (E.g., if line _start_ and _end_ are variables, then length should be a function). In regards of API's it is a bit more complex, as both your code and the external entity will have to have the knowledge, and when changed, the other breaks. To deduplicate API it is possible to specify the API via a neutral format OR have something like OpenAPI generate the documentation for you. The hardest type of duplication to detect and handle is between different developers or projects, and can only be avoided by communication through standups, message threads, and peer reviews. Overall the environment that you should be trying to foster is the one, where it is easier to find and reuse existing stuff than write it yourself.

Orthogonality is a critical concept if you want to produce systems that are easy to design, build, test, document, and extend. The term "Orthogonality" signifies independence or decoupling, and changes can be made without affecting the rest of the system. A non-orthogonal system is a helicopter, in which every change impacts all the other inputs. With orthogonality the effects between unrelated things are eliminated, productivity is gained (through less time needed for developing and testing), and risk is reduced (as when a module is sick, others are not affected). Decouple your design from the real world, don't use phone number,or postal code as a customer identifier, as you should not rely on properties you can't control. The techniques to maintain orthogonality are to keep your code decoupled (Law of Demeter), avoid global data, and similar functions (Strategy pattern). Orthogonality is closely related to the DRY principle, where DRY tries to minimize duplication, and orthogonality to reduce the interdependency among the components.

There are ALWAYS more than one way to implement something, and usually more than one vendor available. If you rely heavily on some fact, you can almost guarantee that it _will_ change, but critical decisions aren't easily reversible around a project. There are no final decisions. Instead of carving decisions in stone, think of them more as being written in the sand at the beach. A big wave can come along and wipe them out at any time. To have easier reversibility, you should have flexible arcitecture: Hide third-party APIs behind your own abstraction layers, break your code into components (even if they are deployed on a single server) as it is a lot easier than splitting a monolithic application.

Prioritize development in the areas of the code, which define the system, and in which you have doubts and see bigger risks. You should take an incremental approach, where a part of every layer (UI, service, DB) is implemented, and use it as a tracer bullet to see whether everything works and you are on target. This approach makes it easier to progress, and make changes, while having something to demonstrate for customers. The idea behind tracer code is to get feedback early on, see whether it is missing, and make easy and quick changes to be on target. Tracer code is different from _prototyping_, because with a true _prototype_ you will throw away everything you lashed together and start on a clean sheetw, whereas with tracer code you build a trivial implementation, which will be added on in the future - the system will continue to work as with the first tracer code.

## Suggestions

### Books to read
- Communications within teams:
  - The Mythicla Man-Month: Essays on Software Engineering
  - Peopleware: Productive Projects and Teams
  - Dinosaur Brains: Dealing with All Those Impossible People at Work

### Read more about
- the Decorator Pattern: adding functionality to functions without changing them.
- Law of Demeter: Decoupling
- Stategy pattern in design patterns

### Tips
- Proofread your emails before you hit SEND and keep the format simple and clean.
- 
